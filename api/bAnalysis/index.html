
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Current Clamp Analysis For Cardiac Myocytes">
      
      
      
        <meta name="author" content="Robert H Cudmore">
      
      
      <link rel="icon" href="../../img/sanpy-transparent.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.6">
    
    
      
        <title>bAnalysis - SanPy Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a57b2b03.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../css/style.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#sanpy.bAnalysis_.bAnalysis.__init__" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="SanPy Documentation" class="md-header__button md-logo" aria-label="SanPy Documentation" data-md-component="logo">
      
  <img src="../../img/sanpy-transparent.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            SanPy Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              bAnalysis
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/cudmore/sanpy" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    SanPy Repository
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="SanPy Documentation" class="md-nav__button md-logo" aria-label="SanPy Documentation" data-md-component="logo">
      
  <img src="../../img/sanpy-transparent.png" alt="logo">

    </a>
    SanPy Documentation
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/cudmore/sanpy" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    SanPy Repository
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        SanPy
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        Install
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../desktop-application/" class="md-nav__link">
        Desktop Application
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../plugins/" class="md-nav__link">
        Plugins
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          Scripting
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Scripting" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Scripting
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../scripting/overview/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../scripting/examples/" class="md-nav__link">
        Examples
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../scripting/plotting-analysis/" class="md-nav__link">
        Plotting Analysis
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          API
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="API" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          API
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../overview/" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          bAnalysis
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        bAnalysis
      </a>
      
        


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.abf" class="md-nav__link">
    abf
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getHeader" class="md-nav__link">
    api_getHeader()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getRecording" class="md-nav__link">
    api_getRecording()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeInfo" class="md-nav__link">
    api_getSpikeInfo()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeStat" class="md-nav__link">
    api_getSpikeStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.asDataFrame" class="md-nav__link">
    asDataFrame()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.dataPointsPerMs" class="md-nav__link">
    dataPointsPerMs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.donotuse_openHeaderInBrowser" class="md-nav__link">
    donotuse_openHeaderInBrowser()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.errorReport" class="md-nav__link">
    errorReport()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.filteredDeriv" class="md-nav__link">
    filteredDeriv
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeClips" class="md-nav__link">
    getSpikeClips()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeDictionaries" class="md-nav__link">
    getSpikeDictionaries()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeTimes" class="md-nav__link">
    getSpikeTimes()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getStat" class="md-nav__link">
    getStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getStatMean" class="md-nav__link">
    getStatMean()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.isAnalyzed" class="md-nav__link">
    isAnalyzed()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.ms2Pnt_" class="md-nav__link">
    ms2Pnt_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.numSpikes" class="md-nav__link">
    numSpikes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.numSweeps" class="md-nav__link">
    numSweeps
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.old_spikeDetect__" class="md-nav__link">
    old_spikeDetect__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.pnt2Ms_" class="md-nav__link">
    pnt2Ms_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.pnt2Sec_" class="md-nav__link">
    pnt2Sec_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.printSpike" class="md-nav__link">
    printSpike()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.recordingDur" class="md-nav__link">
    recordingDur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.recordingFrequency" class="md-nav__link">
    recordingFrequency
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.save_csv" class="md-nav__link">
    save_csv()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.setSpikeStat" class="md-nav__link">
    setSpikeStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect" class="md-nav__link">
    spikeDetect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect2__" class="md-nav__link">
    spikeDetect2__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepC" class="md-nav__link">
    sweepC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepList" class="md-nav__link">
    sweepList
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepY" class="md-nav__link">
    sweepY
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bAnalysisResults/" class="md-nav__link">
        bAnalysisResults
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../analysisPlot/" class="md-nav__link">
        analysisPlot
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../analysisDir/" class="md-nav__link">
        analysisDir
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bExport/" class="md-nav__link">
        bExport
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bDetection/" class="md-nav__link">
        bDetection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bAnalysisUtil/" class="md-nav__link">
        bAnalysisUtil
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../userAnalysis/baseUserAnalysis/" class="md-nav__link">
        baseUserAnalysis
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6_10" type="checkbox" id="__nav_6_10" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6_10">
          interface
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="interface" data-md-level="2">
        <label class="md-nav__title" for="__nav_6_10">
          <span class="md-nav__icon md-icon"></span>
          interface
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../interface/sanpy_app/" class="md-nav__link">
        sanp_app
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6_10_2" type="checkbox" id="__nav_6_10_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6_10_2">
          plugins
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="plugins" data-md-level="3">
        <label class="md-nav__title" for="__nav_6_10_2">
          <span class="md-nav__icon md-icon"></span>
          plugins
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../interface/plugins/sanpyPlugin/" class="md-nav__link">
        sanpyPlugin
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../methods/" class="md-nav__link">
        Methods
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../web-application/" class="md-nav__link">
        Web Application
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../open-source/" class="md-nav__link">
        Open Source
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        About
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.abf" class="md-nav__link">
    abf
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getHeader" class="md-nav__link">
    api_getHeader()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getRecording" class="md-nav__link">
    api_getRecording()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeInfo" class="md-nav__link">
    api_getSpikeInfo()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeStat" class="md-nav__link">
    api_getSpikeStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.asDataFrame" class="md-nav__link">
    asDataFrame()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.dataPointsPerMs" class="md-nav__link">
    dataPointsPerMs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.donotuse_openHeaderInBrowser" class="md-nav__link">
    donotuse_openHeaderInBrowser()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.errorReport" class="md-nav__link">
    errorReport()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.filteredDeriv" class="md-nav__link">
    filteredDeriv
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeClips" class="md-nav__link">
    getSpikeClips()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeDictionaries" class="md-nav__link">
    getSpikeDictionaries()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getSpikeTimes" class="md-nav__link">
    getSpikeTimes()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getStat" class="md-nav__link">
    getStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.getStatMean" class="md-nav__link">
    getStatMean()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.isAnalyzed" class="md-nav__link">
    isAnalyzed()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.ms2Pnt_" class="md-nav__link">
    ms2Pnt_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.numSpikes" class="md-nav__link">
    numSpikes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.numSweeps" class="md-nav__link">
    numSweeps
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.old_spikeDetect__" class="md-nav__link">
    old_spikeDetect__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.pnt2Ms_" class="md-nav__link">
    pnt2Ms_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.pnt2Sec_" class="md-nav__link">
    pnt2Sec_()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.printSpike" class="md-nav__link">
    printSpike()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.recordingDur" class="md-nav__link">
    recordingDur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.recordingFrequency" class="md-nav__link">
    recordingFrequency
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.save_csv" class="md-nav__link">
    save_csv()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.setSpikeStat" class="md-nav__link">
    setSpikeStat()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect" class="md-nav__link">
    spikeDetect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect2__" class="md-nav__link">
    spikeDetect2__()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepC" class="md-nav__link">
    sweepC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepList" class="md-nav__link">
    sweepList
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sanpy.bAnalysis_.bAnalysis.sweepY" class="md-nav__link">
    sweepY
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>bAnalysis</h1>
                
                <div class="doc doc-object doc-class">


    <div class="doc doc-contents first">





  <div class="doc doc-children">




  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theTiff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteStream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fromDf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fromDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loadData</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.__init__" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">


<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>file</code></td>
        <td><code>str</code></td>
        <td><p>Path to either .abf or .csv with time/mV columns.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>theTiff</code></td>
        <td><code>str</code></td>
        <td><p>Path to .tif file.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>byteStream</code></td>
        <td><code>io.BytesIO</code></td>
        <td><p>Binary stream for use in the cloud.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>fromDf</code></td>
        <td></td>
        <td><p>(pd.DataFrame): One row df with columns as instance variables</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>fromDict</code></td>
        <td></td>
        <td><p>(dict): Dict has keys ['sweepX', 'sweepY', 'mode']</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theTiff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byteStream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
				<span class="n">fromDf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fromDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
				<span class="n">loadData</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Args:</span>
<span class="sd">		file (str): Path to either .abf or .csv with time/mV columns.</span>
<span class="sd">		theTiff (str): Path to .tif file.</span>
<span class="sd">		byteStream (io.BytesIO): Binary stream for use in the cloud.</span>
<span class="sd">		fromDf: (pd.DataFrame): One row df with columns as instance variables</span>
<span class="sd">		fromDict: (dict): Dict has keys [&#39;sweepX&#39;, &#39;sweepY&#39;, &#39;mode&#39;]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#logger.info(f&#39;{file}&#39;)</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">detectionClass</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bDetection</span><span class="p">()</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_isAnalyzed</span> <span class="o">=</span> <span class="kc">False</span>

	<span class="c1"># mimic pyAbf</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_dataPointsPerMs</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_currentSweep</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># int</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># list</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepLengthSec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepX</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># np.ndarray</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepY</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># np.ndarray</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepC</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># the command waveform (DAC)</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_filteredVm</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_filteredDeriv</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_recordingMode</span> <span class="o">=</span> <span class="s1">&#39;Unknown&#39;</span>  <span class="c1"># str</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepLabelX</span> <span class="o">=</span> <span class="s1">&#39;???&#39;</span>  <span class="c1"># str</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_sweepLabelY</span> <span class="o">=</span> <span class="s1">&#39;???&#39;</span>  <span class="c1"># str</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">myFileType</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="sd">&quot;&quot;&quot;str: From (&#39;abf&#39;, &#39;csv&#39;, &#39;tif&#39;, &#39;bytestream&#39;)&quot;&quot;&quot;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">loadError</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="sd">&quot;&quot;&quot;bool: True if error loading file/stream.&quot;&quot;&quot;</span>

	<span class="c1">#self.detectionDict = None  # remember the parameters of our last detection</span>
	<span class="sd">&quot;&quot;&quot;dict: Dictionary specifying detection parameters, see bDetection.getDefaultDetection.&quot;&quot;&quot;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">file</span>  <span class="c1"># todo: change this to filePath</span>
	<span class="sd">&quot;&quot;&quot;str: File path.&quot;&quot;&quot;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_abf</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="sd">&quot;&quot;&quot;pyAbf: If loaded from binary .abf file&quot;&quot;&quot;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">dateAnalyzed</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="sd">&quot;&quot;&quot;str: Date Time of analysis. TODO: make a property.&quot;&quot;&quot;</span>

	<span class="c1">#self.detectionType = None</span>
	<span class="sd">&quot;&quot;&quot;str: From (&#39;dvdt&#39;, &#39;mv&#39;)&quot;&quot;&quot;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># a list of dict</span>
	<span class="c1">#self.spikeTimes = []  # created in self.spikeDetect()</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># created in self.spikeDetect()</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x2</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">dfError</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dataframe with a list of detection errors</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">dfReportForScatter</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dataframe to be used by scatterplotwidget</span>

	<span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;File does not exist: &quot;</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">loadError</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="c1"># only defined when loading abf files</span>
	<span class="c1">#self.acqDate = None</span>
	<span class="c1">#self.acqTime = None</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_detectionDirty</span> <span class="o">=</span> <span class="kc">False</span>

	<span class="c1"># will be overwritten by existing uuid in self._loadFromDf()</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">uuid</span> <span class="o">=</span> <span class="n">bAnalysis</span><span class="o">.</span><span class="n">getNewUuid</span><span class="p">()</span>

	<span class="c1"># IMPORTANT:</span>
	<span class="c1">#		All instance variable MUST be declared before we load</span>
	<span class="c1">#		In particular for self._loadFromDf()</span>

	<span class="c1"># instantiate and load abf file</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">isBytesIO</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="k">if</span> <span class="n">fromDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadFromDict</span><span class="p">(</span><span class="n">fromDict</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">fromDf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadFromDf</span><span class="p">(</span><span class="n">fromDf</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">byteStream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadAbf</span><span class="p">(</span><span class="n">byteStream</span><span class="o">=</span><span class="n">byteStream</span><span class="p">,</span> <span class="n">loadData</span><span class="o">=</span><span class="n">loadData</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.abf&#39;</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadAbf</span><span class="p">(</span><span class="n">loadData</span><span class="o">=</span><span class="n">loadData</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.atf&#39;</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadAtf</span><span class="p">(</span><span class="n">loadData</span><span class="o">=</span><span class="n">loadData</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadTif</span><span class="p">()</span>
	<span class="k">elif</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_loadCsv</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">pass</span>
		<span class="c1">#logger.error(f&#39;Can only open abf/csv/tif/stream files: {file}&#39;)</span>
		<span class="c1">#self.loadError = True</span>

	<span class="c1"># get default derivative</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">rebuildFiltered</span><span class="p">()</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	if self._recordingMode == &#39;I-Clamp&#39;:</span>
<span class="sd">		self._getDerivative()</span>
<span class="sd">	elif self._recordingMode == &#39;V-Clamp&#39;:</span>
<span class="sd">		self._getBaselineSubtract()</span>
<span class="sd">	else:</span>
<span class="sd">		logger.warning(&#39;Did not take derivative&#39;)</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_detectionDirty</span> <span class="o">=</span> <span class="kc">False</span>

	<span class="c1"># switching back to faster version (no parsing when we cell self.sweepX2</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">setSweep</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.abf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">abf</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.abf" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the underlying pyabf object.</p>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.api_getHeader" class="doc doc-heading">
<code class="highlight language-python"><span class="n">api_getHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.api_getHeader" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get header as a dict.</p>
<div class="admonition todo">
<p class="admonition-title">Todo<ul>
<li>add info on abf file, like samples per ms</li>
</ul>
</p>
</div>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>Dictionary of information about loaded file.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">api_getHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get header as a dict.</span>

<span class="sd">	TODO:</span>
<span class="sd">		- add info on abf file, like samples per ms</span>

<span class="sd">	Returns:</span>
<span class="sd">		dict: Dictionary of information about loaded file.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#recordingDir_sec = len(self.sweepX) / self.dataPointsPerMs / 1000</span>
	<span class="n">recordingFrequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s1">&#39;myFileType&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">myFileType</span><span class="p">,</span> <span class="c1"># (&#39;abf&#39;, &#39;tif&#39;, &#39;bytestream&#39;, &#39;csv&#39;)</span>
		<span class="s1">&#39;loadError&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadError</span><span class="p">,</span>
		<span class="c1">#&#39;detectionDict&#39;: self.detectionClass,</span>
		<span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span>
		<span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFileName</span><span class="p">(),</span>
		<span class="s1">&#39;dateAnalyzed&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateAnalyzed</span><span class="p">,</span>
		<span class="c1">#&#39;detectionType&#39;: self.detectionType,</span>
		<span class="c1">#&#39;acqDate&#39;: self.acqDate,</span>
		<span class="c1">#&#39;acqTime&#39;: self.acqTime,</span>
		<span class="c1">#</span>
		<span class="s1">&#39;_recordingMode&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recordingMode</span><span class="p">,</span>
		<span class="s1">&#39;get_yUnits&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yUnits</span><span class="p">(),</span>
		<span class="c1">#&#39;currentSweep&#39;: self.currentSweep,</span>
		<span class="s1">&#39;recording_kHz&#39;</span><span class="p">:</span> <span class="n">recordingFrequency</span><span class="p">,</span>
		<span class="s1">&#39;recordingDur_sec&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">recordingDur</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.api_getRecording" class="doc doc-heading">
<code class="highlight language-python"><span class="n">api_getRecording</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.api_getRecording" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Return primary recording</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>{'header', 'sweepX', 'sweepY'}</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition todo">
<p class="admonition-title">Todo<p>Add param to only get every n'th point, to return a subset faster (for display)</p>
</p>
</div>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">api_getRecording</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Return primary recording</span>

<span class="sd">	Returns:</span>
<span class="sd">		dict: {&#39;header&#39;, &#39;sweepX&#39;, &#39;sweepY&#39;}</span>

<span class="sd">	TODO:</span>
<span class="sd">		Add param to only get every n&#39;th point, to return a subset faster (for display)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#start = time.time()</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s1">&#39;header&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">api_getHeader</span><span class="p">(),</span>
		<span class="s1">&#39;sweepX&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepX2</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
		<span class="s1">&#39;sweepY&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepY2</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="c1">#stop = time.time()</span>
	<span class="c1">#print(stop-start)</span>
	<span class="k">return</span> <span class="n">ret</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.api_getSpikeInfo" class="doc doc-heading">
<code class="highlight language-python"><span class="n">api_getSpikeInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikeNum</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeInfo" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get info about each spike.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>spikeNum</code></td>
        <td><code>int</code></td>
        <td><p>Get info for one spike, None for all spikes.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>List of dict with info for all (one) spike.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">api_getSpikeInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikeNum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get info about each spike.</span>

<span class="sd">	Args:</span>
<span class="sd">		spikeNum (int): Get info for one spike, None for all spikes.</span>

<span class="sd">	Returns:</span>
<span class="sd">		list: List of dict with info for all (one) spike.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">spikeNum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">spikeNum</span><span class="p">]]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span>
	<span class="k">return</span> <span class="n">ret</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.api_getSpikeStat" class="doc doc-heading">
<code class="highlight language-python"><span class="n">api_getSpikeStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.api_getSpikeStat" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get stat for each spike</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>stat</code></td>
        <td><code>str</code></td>
        <td><p>The name of the stat to get. Corresponds to key in self.spikeDict[i].</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>List of values for 'stat'. Ech value is for one spike.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">api_getSpikeStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stat</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get stat for each spike</span>

<span class="sd">	Args:</span>
<span class="sd">		stat (str): The name of the stat to get. Corresponds to key in self.spikeDict[i].</span>

<span class="sd">	Returns:</span>
<span class="sd">		list: List of values for &#39;stat&#39;. Ech value is for one spike.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">statList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStat</span><span class="p">(</span><span class="n">statName1</span><span class="o">=</span><span class="n">stat</span><span class="p">,</span> <span class="n">statName2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">statList</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.asDataFrame" class="doc doc-heading">
<code class="highlight language-python"><span class="n">asDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.asDataFrame" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Return analysis as a Pandas DataFrame.</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">asDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Return analysis as a Pandas DataFrame.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="o">.</span><span class="n">aslist</span><span class="p">())</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.dataPointsPerMs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">dataPointsPerMs</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.dataPointsPerMs" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the number of data points per ms.</p>
    </div>

  </div>











  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.donotuse_openHeaderInBrowser" class="doc doc-heading">
<code class="highlight language-python"><span class="n">donotuse_openHeaderInBrowser</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.donotuse_openHeaderInBrowser" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Open abf file header in browser. Only works for actual abf files.</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">donotuse_openHeaderInBrowser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Open abf file header in browser. Only works for actual abf files.&quot;&quot;&quot;</span>
	<span class="c1">#ba.abf.headerLaunch()</span>
	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="kn">import</span> <span class="nn">webbrowser</span>
	<span class="n">logFile</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">sanpyLogger</span><span class="o">.</span><span class="n">getLoggerFile</span><span class="p">()</span>
	<span class="n">htmlFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">logFile</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.html&#39;</span>
	<span class="c1">#print(&#39;htmlFile:&#39;, htmlFile)</span>
	<span class="n">html</span> <span class="o">=</span> <span class="n">pyabf</span><span class="o">.</span><span class="n">abfHeaderDisplay</span><span class="o">.</span><span class="n">abfInfoPage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="p">)</span><span class="o">.</span><span class="n">generateHTML</span><span class="p">()</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">htmlFile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
		<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
	<span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;file://&#39;</span> <span class="o">+</span> <span class="n">htmlFile</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.errorReport" class="doc doc-heading">
<code class="highlight language-python"><span class="n">errorReport</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.errorReport" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Generate an error report, one row per error. Spikes can have more than one error.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(pandas DataFrame)</code></td>
      <td><p>Pandas DataFrame, one row per error.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">errorReport</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Generate an error report, one row per error. Spikes can have more than one error.</span>

<span class="sd">	Returns:</span>
<span class="sd">		(pandas DataFrame): Pandas DataFrame, one row per error.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">dictList</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="n">numError</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">errorList</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">spikeIdx</span><span class="p">,</span> <span class="n">spike</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spike</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]):</span>
			<span class="c1"># error is dict from _getErorDict</span>
			<span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">error</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="ow">or</span> <span class="n">error</span> <span class="o">==</span> <span class="s1">&#39;nan&#39;</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="n">dictList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">fakeErrorDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;fake&#39;</span><span class="p">,</span> <span class="s1">&#39;fake&#39;</span><span class="p">)</span>
		<span class="n">dfError</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">fakeErrorDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">dfError</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dictList</span><span class="p">)</span>

	<span class="c1">#print(&#39;bAnalysis.errorReport() returning len(dfError):&#39;, len(dfError))</span>
	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">detectionClass</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dfError</span><span class="p">)</span><span class="si">}</span><span class="s1"> errors in spike detection&#39;</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="k">return</span> <span class="n">dfError</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.filteredDeriv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">filteredDeriv</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.filteredDeriv" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the command waveform DAC (numpy.ndarray). Units will depend on mode</p>
    </div>

  </div>




















  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.getSpikeClips" class="doc doc-heading">
<code class="highlight language-python"><span class="n">getSpikeClips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theMin</span><span class="p">,</span> <span class="n">theMax</span><span class="p">,</span> <span class="n">spikeSelection</span><span class="o">=</span><span class="p">[],</span> <span class="n">preSpikeClipWidth_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postSpikeClipWidth_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.getSpikeClips" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get 2d list of spike clips, spike clips x, and 1d mean spike clip</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>theMin</code></td>
        <td><code>float</code></td>
        <td><p>Start seconds.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>theMax</code></td>
        <td><code>float</code></td>
        <td><p>Stop seconds.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>spikeSelection</code></td>
        <td><code>list</code></td>
        <td><p>List of spike numbers</p></td>
        <td><code>[]</code></td>
      </tr>
      <tr>
        <td><code>preSpikeClipWidth_ms</code></td>
        <td><code>float</code></td>
        <td></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>postSpikeClipWidth_ms</code></td>
        <td><code>float</code></td>
        <td></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>      <p>Requires: self.spikeDetect() and self._makeSpikeClips()</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>theseClips (list)</code></td>
      <td><p>List of clip
theseClips_x (list): ms
meanClip (list)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getSpikeClips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theMin</span><span class="p">,</span> <span class="n">theMax</span><span class="p">,</span> <span class="n">spikeSelection</span><span class="o">=</span><span class="p">[],</span> <span class="n">preSpikeClipWidth_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postSpikeClipWidth_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get 2d list of spike clips, spike clips x, and 1d mean spike clip</span>

<span class="sd">	Args:</span>
<span class="sd">		theMin (float): Start seconds.</span>
<span class="sd">		theMax (float): Stop seconds.</span>
<span class="sd">		spikeSelection (list): List of spike numbers</span>
<span class="sd">		preSpikeClipWidth_ms (float):</span>
<span class="sd">		postSpikeClipWidth_ms (float):</span>

<span class="sd">	Requires: self.spikeDetect() and self._makeSpikeClips()</span>

<span class="sd">	Returns:</span>
<span class="sd">		theseClips (list): List of clip</span>
<span class="sd">		theseClips_x (list): ms</span>
<span class="sd">		meanClip (list)</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSpikes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span>

	<span class="n">doSpikeSelection</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikeSelection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="n">doSpikeSelection</span><span class="p">:</span>
		<span class="k">pass</span>
	<span class="k">elif</span> <span class="n">theMin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">theMax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">theMin</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">theMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recordingDur</span>  <span class="c1"># self.sweepX[-1]</span>

	<span class="c1"># new interface, spike detect no longer auto generates these</span>
	<span class="c1"># need to do this every time because we get here when sweepNumber changes</span>
	<span class="c1">#if self.spikeClips is None:</span>
	<span class="c1">#	self._makeSpikeClips(spikeClipWidth_ms=spikeClipWidth_ms, sweepNumber=sweepNumber)</span>
	<span class="c1"># TODO: don&#39;t make all clips</span>
	<span class="c1">#self._makeSpikeClips(spikeClipWidth_ms=spikeClipWidth_ms, sweepNumber=sweepNumber)</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_makeSpikeClips</span><span class="p">(</span><span class="n">preSpikeClipWidth_ms</span><span class="o">=</span><span class="n">preSpikeClipWidth_ms</span><span class="p">,</span> <span class="n">postSpikeClipWidth_ms</span><span class="o">=</span><span class="n">postSpikeClipWidth_ms</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="n">sweepNumber</span><span class="p">)</span>

	<span class="c1"># make a list of clips within start/stop (Seconds)</span>
	<span class="n">theseClips</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">theseClips_x</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">tmpMeanClips</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># for mean clip</span>
	<span class="n">meanClip</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">spikeTimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpikeTimes</span><span class="p">(</span><span class="n">sweepNumber</span><span class="o">=</span><span class="n">sweepNumber</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span><span class="p">):</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;len spikeTimes !=  spikeClips </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

	<span class="c1"># self.spikeClips is a list of clips</span>
	<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">clip</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span><span class="p">):</span>
		<span class="n">doThisSpike</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">if</span> <span class="n">doSpikeSelection</span><span class="p">:</span>
			<span class="n">doThisSpike</span> <span class="o">=</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">spikeSelection</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">spikeTime</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
			<span class="n">spikeTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Sec_</span><span class="p">(</span><span class="n">spikeTime</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">spikeTime</span><span class="o">&gt;=</span><span class="n">theMin</span> <span class="ow">and</span> <span class="n">spikeTime</span><span class="o">&lt;=</span><span class="n">theMax</span><span class="p">:</span>
				<span class="n">doThisSpike</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">if</span> <span class="n">doThisSpike</span><span class="p">:</span>
			<span class="n">theseClips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span>
			<span class="n">theseClips_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x2</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="c1"># remember, all _x are the same</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">clip</span><span class="p">):</span>
				<span class="n">tmpMeanClips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span> <span class="c1"># for mean clip</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpMeanClips</span><span class="p">):</span>
		<span class="n">meanClip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tmpMeanClips</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">theseClips</span><span class="p">,</span> <span class="n">theseClips_x</span><span class="p">,</span> <span class="n">meanClip</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.getSpikeDictionaries" class="doc doc-heading">
<code class="highlight language-python"><span class="n">getSpikeDictionaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.getSpikeDictionaries" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get spike dictionaries for current sweep</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getSpikeDictionaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Get spike dictionaries for current sweep</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">sweepNumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">sweepNumber</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span>
	<span class="c1">#logger.info(f&#39;sweepNumber:{sweepNumber}&#39;)</span>
	<span class="n">theRet</span> <span class="o">=</span> <span class="p">[</span><span class="n">spike</span> <span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="k">if</span> <span class="n">sweepNumber</span><span class="o">==</span><span class="s1">&#39;All&#39;</span> <span class="ow">or</span> <span class="n">spike</span><span class="p">[</span><span class="s1">&#39;sweep&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">sweepNumber</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">theRet</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.getSpikeTimes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">getSpikeTimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.getSpikeTimes" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get spike times for current sweep</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getSpikeTimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Get spike times for current sweep</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#theRet = [spike[&#39;thresholdPnt&#39;] for spike in self.spikeDict if spike[&#39;sweep&#39;]==self.currentSweep]</span>
	<span class="n">theRet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStat</span><span class="p">(</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="n">sweepNumber</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">theRet</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.getStat" class="doc doc-heading">
<code class="highlight language-python"><span class="n">getStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statName1</span><span class="p">,</span> <span class="n">statName2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asArray</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.getStat" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get a list of values for one or two analysis parameters.</p>
<p>For a list of available analysis parameters, use <a href="../bDetection/#sanpy.bDetection.bDetection">bDetection.getDefaultDetection()</a></p>
<p>If the returned list of analysis parameters are in points,
        convert to seconds or ms using: pnt2Sec_(pnt) or pnt2Ms_(pnt).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>statName1</code></td>
        <td><code>str</code></td>
        <td><p>Name of the first analysis parameter to retreive.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>statName2</code></td>
        <td><code>str</code></td>
        <td><p>Optional, Name of the second analysis parameter to retreive.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>List of analysis parameter values, None if error.</p></td>
    </tr>
  </tbody>
</table>      <p>TODO: Add convertToSec (bool)</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statName1</span><span class="p">,</span> <span class="n">statName2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asArray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get a list of values for one or two analysis parameters.</span>

<span class="sd">	For a list of available analysis parameters, use [bDetection.getDefaultDetection()][sanpy.bDetection.bDetection]</span>

<span class="sd">	If the returned list of analysis parameters are in points,</span>
<span class="sd">		convert to seconds or ms using: pnt2Sec_(pnt) or pnt2Ms_(pnt).</span>

<span class="sd">	Args:</span>
<span class="sd">		statName1 (str): Name of the first analysis parameter to retreive.</span>
<span class="sd">		statName2 (str): Optional, Name of the second analysis parameter to retreive.</span>

<span class="sd">	Returns:</span>
<span class="sd">		list: List of analysis parameter values, None if error.</span>

<span class="sd">	TODO: Add convertToSec (bool)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Convert None to float(&#39;nan&#39;)&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">val</span>

	<span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># None</span>
	<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># None</span>
	<span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">#logger.error(f&#39;Did not find any spikes in spikeDict&#39;)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>
	<span class="k">elif</span> <span class="n">statName1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Did not find statName1: &quot;</span><span class="si">{</span><span class="n">statName1</span><span class="si">}</span><span class="s1">&quot; in spikeDict&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>
	<span class="k">elif</span> <span class="n">statName2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">statName2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Did not find statName2: &quot;</span><span class="si">{</span><span class="n">statName2</span><span class="si">}</span><span class="s1">&quot; in spikeDict&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="k">if</span> <span class="n">sweepNumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">sweepNumber</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span>

	<span class="k">if</span> <span class="ow">not</span> <span class="n">error</span><span class="p">:</span>
		<span class="c1"># original</span>
		<span class="c1">#x = [clean(spike[statName1]) for spike in self.spikeDict]</span>
		<span class="c1"># only current spweek</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">clean</span><span class="p">(</span><span class="n">spike</span><span class="p">[</span><span class="n">statName1</span><span class="p">])</span> <span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="k">if</span> <span class="p">(</span><span class="n">sweepNumber</span><span class="o">==</span><span class="s1">&#39;All&#39;</span> <span class="ow">or</span> <span class="n">spike</span><span class="p">[</span><span class="s1">&#39;sweep&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">sweepNumber</span><span class="p">)]</span>

		<span class="k">if</span> <span class="n">statName2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="c1"># original</span>
			<span class="c1">#y = [clean(spike[statName2]) for spike in self.spikeDict]</span>
			<span class="c1"># only current spweek</span>
			<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">clean</span><span class="p">(</span><span class="n">spike</span><span class="p">[</span><span class="n">statName2</span><span class="p">])</span> <span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="k">if</span> <span class="n">sweepNumber</span><span class="o">==</span><span class="s1">&#39;All&#39;</span> <span class="ow">or</span> <span class="n">spike</span><span class="p">[</span><span class="s1">&#39;sweep&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">sweepNumber</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">asArray</span><span class="p">:</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">statName2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">statName2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">x</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.getStatMean" class="doc doc-heading">
<code class="highlight language-python"><span class="n">getStatMean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statName</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.getStatMean" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the mean of an analysis parameter.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>statName</code></td>
        <td><code>str</code></td>
        <td><p>Name of the statistic to retreive.
For a list of available stats use bDetection.defaultDetection.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getStatMean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statName</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Get the mean of an analysis parameter.</span>

<span class="sd">	Args:</span>
<span class="sd">		statName (str): Name of the statistic to retreive.</span>
<span class="sd">			For a list of available stats use bDetection.defaultDetection.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">theMean</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStat</span><span class="p">(</span><span class="n">statName</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="o">=</span><span class="n">sweepNumber</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
		<span class="n">theMean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">theMean</span>
</code></pre></div>
        </details>
    </div>

  </div>











  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.isAnalyzed" class="doc doc-heading">
<code class="highlight language-python"><span class="n">isAnalyzed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.isAnalyzed" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Return True if this bAnalysis has been analyzed, False otherwise.</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">isAnalyzed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Return True if this bAnalysis has been analyzed, False otherwise.&quot;&quot;&quot;</span>
	<span class="c1">#return self.detectionDict is not None</span>
	<span class="c1">#return self.numSpikes &gt; 0</span>
	<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isAnalyzed</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.ms2Pnt_" class="doc doc-heading">
<code class="highlight language-python"><span class="n">ms2Pnt_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.ms2Pnt_" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Convert milliseconds (ms) to point in recording using <code>self.dataPointsPerMs</code></p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ms</code></td>
        <td><code>float</code></td>
        <td><p>The ms into the recording</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>int</code></td>
      <td><p>The point in the recording</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ms2Pnt_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Convert milliseconds (ms) to point in recording using `self.dataPointsPerMs`</span>

<span class="sd">	Args:</span>
<span class="sd">		ms (float): The ms into the recording</span>

<span class="sd">	Returns:</span>
<span class="sd">		int: The point in the recording</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">theRet</span> <span class="o">=</span> <span class="n">ms</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span>
	<span class="c1">#theRet = int(theRet)</span>
	<span class="n">theRet</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">theRet</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">theRet</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.numSpikes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">numSpikes</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.numSpikes" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the total number of detected spikes.</p>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.numSweeps" class="doc doc-heading">
<code class="highlight language-python"><span class="n">numSweeps</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.numSweeps" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the number of sweeps.</p>
    </div>

  </div>











  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.old_spikeDetect__" class="doc doc-heading">
<code class="highlight language-python"><span class="n">old_spikeDetect__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.old_spikeDetect__" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Spike detect the current sweep and put results into list of dict <code>self.spikeDict[]</code>.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dDict</code></td>
        <td><code>bDetection</code></td>
        <td><p>A detection class/dictionary from [bDetection()][sanpy.bDetection]</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">old_spikeDetect__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Spike detect the current sweep and put results into list of dict `self.spikeDict[]`.</span>

<span class="sd">	Args:</span>
<span class="sd">		dDict (bDetection): A detection class/dictionary from [bDetection()][sanpy.bDetection]</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="k">if</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;dDict is:&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1"> &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">sweepNumber</span><span class="p">)</span>
	<span class="c1">#</span>

	<span class="c1"># in case dDict has new filter values</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">rebuildFiltered</span><span class="p">()</span>

	<span class="c1">#</span>
	<span class="c1"># spike detect</span>
	<span class="n">detectionType</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;detectionType&#39;</span><span class="p">]</span>
	<span class="c1">#logger.info(f&#39;detectionType: &quot;{detectionType}&#39;)</span>

	<span class="c1"># detect all spikes either with dvdt or mv</span>
	<span class="k">if</span> <span class="n">detectionType</span> <span class="o">==</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bDetection</span><span class="o">.</span><span class="n">detectionTypes</span><span class="o">.</span><span class="n">mv</span><span class="p">:</span>
		<span class="c1"># detect using mV threshold</span>
		<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikeDetect_vm</span><span class="p">(</span><span class="n">dDict</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">)</span>

		<span class="c1"># backup childish vm threshold</span>
		<span class="k">if</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;doBackupSpikeVm&#39;</span><span class="p">]:</span>
			<span class="c1">#self.spikeTimes = self._backupSpikeVm(dDict[&#39;medianFilter&#39;])</span>
			<span class="n">spikeTimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backupSpikeVm</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">])</span>
	<span class="k">elif</span> <span class="n">detectionType</span> <span class="o">==</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bDetection</span><span class="o">.</span><span class="n">detectionTypes</span><span class="o">.</span><span class="n">dvdt</span><span class="p">:</span>
		<span class="c1"># detect using dv/dt threshold AND min mV</span>
		<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikeDetect_dvdt</span><span class="p">(</span><span class="n">dDict</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown detection type &quot;</span><span class="si">{</span><span class="n">detectionType</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
		<span class="k">return</span>

	<span class="c1">#</span>
	<span class="c1"># set up</span>
	<span class="n">sweepX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepX</span>  <span class="c1"># sweepNumber is not optional</span>
	<span class="n">filteredVm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredVm</span>  <span class="c1"># sweepNumber is not optional</span>
	<span class="n">filteredDeriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredDeriv</span>
	<span class="n">sweepC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepC</span>

	<span class="c1">#</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
	<span class="n">dateStr</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">dateAnalyzed</span> <span class="o">=</span> <span class="n">dateStr</span>

	<span class="c1">#</span>
	<span class="c1"># look in a window after each threshold crossing to get AP peak</span>
	<span class="n">peakWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;peakWindow_ms&#39;</span><span class="p">])</span>

	<span class="c1">#</span>
	<span class="c1"># throw out spikes that have peak BELOW onlyPeaksAbove_mV</span>
	<span class="c1"># throw out spikes that have peak ABOVE onlyPeaksBelow_mV</span>
	<span class="n">onlyPeaksAbove_mV</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;onlyPeaksAbove_mV&#39;</span><span class="p">]</span>
	<span class="n">onlyPeaksBelow_mV</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;onlyPeaksBelow_mV&#39;</span><span class="p">]</span>
	<span class="n">spikeTimes</span><span class="p">,</span><span class="n">spikeErrorList</span><span class="p">,</span> <span class="n">newSpikePeakPnt</span><span class="p">,</span> <span class="n">newSpikePeakVal</span> \
	 				<span class="o">=</span> <span class="n">throwOutAboveBelow_</span><span class="p">(</span><span class="n">filteredVm</span><span class="p">,</span>
							<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span><span class="p">,</span>
							<span class="n">peakWindow_pnts</span><span class="p">,</span>
							<span class="n">onlyPeaksAbove_mV</span><span class="o">=</span><span class="n">onlyPeaksAbove_mV</span><span class="p">,</span>
							<span class="n">onlyPeaksBelow_mV</span><span class="o">=</span><span class="n">onlyPeaksBelow_mV</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="c1"># small window to average Vm to calculate MDP (itself in a window before spike)</span>
	<span class="n">avgWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;avgWindow_ms&#39;</span><span class="p">])</span>
	<span class="n">avgWindow_pnts</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">avgWindow_pnts</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="c1"># for each spike</span>
	<span class="n">numSpikes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spikeTime</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">):</span>
		<span class="c1"># spikeTime units is ALWAYS points</span>

		<span class="c1"># get the AP peak</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		peakPnt = np.argmax(filteredVm[spikeTime:spikeTime+peakWindow_pnts])</span>
<span class="sd">		peakPnt += spikeTime</span>
<span class="sd">		peakVal = np.max(filteredVm[spikeTime:spikeTime+peakWindow_pnts])</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">peakPnt</span> <span class="o">=</span> <span class="n">newSpikePeakPnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">peakVal</span> <span class="o">=</span> <span class="n">newSpikePeakVal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">peakSec</span> <span class="o">=</span> <span class="p">(</span><span class="n">newSpikePeakPnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>

		<span class="c1">#</span>
		<span class="c1"># todo: break this out into a configuration file with</span>
		<span class="c1"># {</span>
		<span class="c1">#	&#39;name&#39;: analysisVersion,</span>
		<span class="c1">#	&#39;type&#39;: &#39;str&#39;,</span>
		<span class="c1">#	&#39;description&#39;: &#39;The analysis version&#39;</span>
		<span class="c1"># }</span>

		<span class="c1"># create one spike dictionary</span>
		<span class="n">spikeDict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># use OrderedDict so Pandas output is in the correct order</span>

		<span class="c1">#spikeDict[&#39;isBad&#39;] = False</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;analysisVersion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">analysisVersion</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;interfaceVersion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">interfaceVersion</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFileName</span><span class="p">()</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;detectionType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectionType</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;cellType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;cellType&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;sex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;sex&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;sweep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sweepNumber</span>
		<span class="c1"># keep track of per sweep spike and total spike</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;sweepSpikeNumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;spikeNumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># self.numSpikes</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;include&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="c1"># todo: make this a byte encoding so we can have multiple user tyes per spike</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;userType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># One userType (int) that can have values</span>

		<span class="c1">#spikeDict[&#39;userType2&#39;] = False</span>
		<span class="c1">#spikeDict[&#39;userType3&#39;] = False</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c1"># append existing spikeErrorList from spikeDetect_dvdt() or spikeDetect_mv()</span>
		<span class="n">tmpError</span> <span class="o">=</span> <span class="n">spikeErrorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">tmpError</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmpError</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
			<span class="c1">#spikeDict[&#39;numError&#39;] += 1</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpError</span><span class="p">)</span> <span class="c1"># tmpError is from:</span>
			<span class="c1">#eDict = self._getErrorDict(i, spikeTime, errType, errStr) # spikeTime is in pnts</span>

		<span class="c1">#</span>
		<span class="c1"># detection params</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;dvdtThreshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;dvdtThreshold&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;mvThreshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;mvThreshold&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikeTime</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;thresholdSec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">spikeTime</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;thresholdVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span> <span class="c1"># in vm</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;thresholdVal_dvdt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span> <span class="c1"># in dvdt, spikeTime is points</span>

		<span class="c1"># DAC command at the precise spike point</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;dacCommand&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sweepC</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span>  <span class="c1"># spikeTime is in points</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;peakPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakPnt</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;peakSec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakSec</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;peakVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakVal</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;peakHeight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;peakVal&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">spikeDict</span><span class="p">[</span><span class="s1">&#39;thresholdVal&#39;</span><span class="p">]</span>

		<span class="c1">#</span>
		<span class="c1"># only append to spikeDict after we are done (accounting for spikes within a sweep)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spikeDict</span><span class="p">)</span>
		<span class="n">iIdx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="c1">#</span>
		<span class="c1">#</span>

		<span class="n">defaultVal</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>

		<span class="c1"># get pre/post spike minima</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>

		<span class="c1"># early diastolic duration</span>
		<span class="c1"># 0.1 to 0.5 of time between pre spike min and spike time</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># seconds between preLinearFitPnt0 and preLinearFitPnt1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
		<span class="c1"># m,b = np.polyfit(x, y, 1)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># fit of y=preLinearFitVal 0/1 versus x=preLinearFitPnt 0/1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;lateDiastolicDuration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1">#</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># in units mV</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># in units dv/dt</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># in units mV</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># in units dv/dt</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># time between successive AP thresholds (thresholdSec)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># time between successive AP thresholds (thresholdSec)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;spikeFreq_hz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># time between successive AP thresholds (thresholdSec)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># time between successive MDPs</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span> <span class="c1"># time between successive MDPs</span>

		<span class="c1"># Action potential duration (APD) was defined as the interval between the TOP and the subsequent MDP</span>
		<span class="c1">#self.spikeDict[iIdx][&#39;apDuration_ms&#39;] = defaultVal</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;diastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>

		<span class="c1"># any number of spike widths</span>
		<span class="c1">#print(&#39;spikeDetect__() appending widths list to spike iIdx:&#39;, iIdx)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">halfHeight</span> <span class="ow">in</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]:</span>
			<span class="n">widthDict</span> <span class="o">=</span> <span class="p">{</span>
				<span class="s1">&#39;halfHeight&#39;</span><span class="p">:</span> <span class="n">halfHeight</span><span class="p">,</span>
				<span class="s1">&#39;risingPnt&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
				<span class="s1">&#39;risingVal&#39;</span><span class="p">:</span> <span class="n">defaultVal</span><span class="p">,</span>
				<span class="s1">&#39;fallingPnt&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
				<span class="s1">&#39;fallingVal&#39;</span><span class="p">:</span> <span class="n">defaultVal</span><span class="p">,</span>
				<span class="s1">&#39;widthPnts&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
				<span class="s1">&#39;widthMs&#39;</span><span class="p">:</span> <span class="n">defaultVal</span>
			<span class="p">}</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;widths_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">halfHeight</span><span class="p">)]</span> <span class="o">=</span> <span class="n">defaultVal</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">widthDict</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="n">mdp_ms</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;mdp_ms&#39;</span><span class="p">]</span>
		<span class="n">mdp_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">mdp_ms</span><span class="p">)</span>  <span class="c1"># mdp_ms * self.dataPointsPerMs</span>
		<span class="n">mdp_pnts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mdp_pnts</span><span class="p">)</span>

		<span class="c1"># pre spike min</span>
		<span class="c1"># other algorithms look between spike[i-1] and spike[i]</span>
		<span class="c1"># here we are looking in a predefined window</span>
		<span class="n">startPnt</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">mdp_pnts</span>
		<span class="k">if</span> <span class="n">startPnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;TODO: add an official warning, we went past 0 for pre spike mdp ms window&#39;</span><span class="p">)</span>
			<span class="n">startPnt</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">startPnt</span><span class="p">:</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1"># EXCEPTION</span>
		<span class="n">preMinPnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span>
		<span class="n">preMinPnt</span> <span class="o">+=</span> <span class="n">startPnt</span>
		<span class="c1"># the pre min is actually an average around the real minima</span>
		<span class="n">avgRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preMinPnt</span><span class="o">-</span><span class="n">avgWindow_pnts</span><span class="p">:</span><span class="n">preMinPnt</span><span class="o">+</span><span class="n">avgWindow_pnts</span><span class="p">]</span>
		<span class="n">preMinVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">avgRange</span><span class="p">)</span>

		<span class="c1"># search backward from spike to find when vm reaches preMinVal (avg)</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preMinPnt</span><span class="p">:</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span> <span class="c1"># we want to search backwards from peak</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">preMinPnt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">preRange</span><span class="o">&lt;</span><span class="n">preMinVal</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">preMinPnt</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">preMinPnt2</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preMinPnt</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preMinVal</span>

		<span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Pre spike min (mdp)&#39;</span>
			<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Did not find preMinVal: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">preMinVal</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1">#+ &#39; postRange min:&#39; + str(np.min(postRange)) + &#39; max &#39; + str(np.max(postRange))</span>
			<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># The nonlinear late diastolic depolarization phase was</span>
		<span class="c1"># estimated as the duration between 1% and 10% dV/dt</span>
		<span class="c1"># linear fit on 10% - 50% of the time from preMinPnt to self.spikeTimes[i]</span>
		<span class="n">startLinearFit</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># percent of time between pre spike min and AP peak</span>
		<span class="n">stopLinearFit</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1">#</span>
		<span class="n">timeInterval_pnts</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">preMinPnt</span>
		<span class="c1"># taking round() so we always get an integer # points</span>
		<span class="n">preLinearFitPnt0</span> <span class="o">=</span> <span class="n">preMinPnt</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="n">timeInterval_pnts</span> <span class="o">*</span> <span class="n">startLinearFit</span><span class="p">)</span>
		<span class="n">preLinearFitPnt1</span> <span class="o">=</span> <span class="n">preMinPnt</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="n">timeInterval_pnts</span> <span class="o">*</span> <span class="n">stopLinearFit</span><span class="p">)</span>
		<span class="n">preLinearFitVal0</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">]</span>
		<span class="n">preLinearFitVal1</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>

		<span class="c1"># linear fit before spike</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitPnt0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitPnt1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">preLinearFitPnt1</span> <span class="o">-</span> <span class="n">preLinearFitPnt0</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitVal0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitVal1</span>

		<span class="c1"># a linear fit where &#39;m,b = np.polyfit(x, y, 1)&#39;</span>
		<span class="c1"># m*x+b&quot;</span>
		<span class="n">xFit</span> <span class="o">=</span> <span class="n">sweepX</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">:</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>  <span class="c1"># abb added +1</span>
		<span class="n">yFit</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">:</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>

		<span class="c1"># sometimes xFit/yFit have 0 length --&gt;&gt; TypeError</span>
		<span class="c1">#print(f&#39; {iIdx} preLinearFitPnt0:{preLinearFitPnt0}, preLinearFitPnt1:{preLinearFitPnt1}&#39;)</span>
		<span class="c1">#print(f&#39;    xFit:{len(xFit)} yFit:{len(yFit)}&#39;)</span>

		<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">mLinear</span><span class="p">,</span> <span class="n">bLinear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xFit</span><span class="p">,</span> <span class="n">yFit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># m is slope, b is intercept</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mLinear</span>
				<span class="c1"># todo: make an error if edd rate is too low</span>
				<span class="n">lowestEddRate</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;lowEddRate_warning&#39;</span><span class="p">]</span>  <span class="c1">#8</span>
				<span class="k">if</span> <span class="n">mLinear</span> <span class="o">&lt;=</span> <span class="n">lowestEddRate</span><span class="p">:</span>
					<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
					<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - Too low&#39;</span>
					<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>

			<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="c1">#catching exception:  expected non-empty vector for x</span>
				<span class="c1"># xFit/yFit turn up empty when mdp and TOP points are within 1 point</span>
				<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				print(&#39;!!!!!! ERROR is e:&#39;, e)</span>
<span class="sd">				print (&#39;  xFit:&#39;, xFit)</span>
<span class="sd">				print (&#39;  yFit:&#39;, yFit)</span>
<span class="sd">				print(&#39;  preLinearFitPnt0:&#39;, preLinearFitPnt0)</span>
<span class="sd">				print(&#39;  preLinearFitPnt1:&#39;, preLinearFitPnt1)</span>
<span class="sd">				&#39;&#39;&#39;</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="c1">#errorStr = &#39;Early diastolic duration rate fit - TypeError&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - preMinPnt == spikePnt&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
			<span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="c1">#logger.error(&#39;== FIX preLinearFitPnt0/preLinearFitPnt1 RankWarning&#39;)</span>
				<span class="c1">#logger.error(f&#39;  error is: {e}&#39;)</span>
				<span class="c1">#print(&#39;RankWarning&#39;)</span>
				<span class="c1"># also throws: RankWarning: Polyfit may be poorly conditioned</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - RankWarning&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; !!!!!!!!!!!!!!!!!!!!!!!!!!! UNKNOWN EXCEPTION DURING EDD LINEAR FIT for spike </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - Unknown Exception&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>

		<span class="c1"># not implemented</span>
		<span class="c1">#self.spikeDict[i][&#39;lateDiastolicDuration&#39;] = ???</span>

		<span class="c1">#</span>
		<span class="c1"># maxima in dv/dt before spike (between TOP and peak)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">peakPnt</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">preSpike_dvdt_max_pnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span>
			<span class="n">preSpike_dvdt_max_pnt</span> <span class="o">+=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preSpike_dvdt_max_pnt</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preSpike_dvdt_max_pnt</span><span class="p">]</span> <span class="c1"># in units mV</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">preSpike_dvdt_max_pnt</span><span class="p">]</span> <span class="c1"># in units mV</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="c1">#self.spikeDict[iIdx][&#39;numError&#39;] = self.spikeDict[iIdx][&#39;numError&#39;] + 1</span>
			<span class="c1"># sometimes preRange is empty, don&#39;t try and put min/max in error</span>
			<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Pre Spike dvdt&#39;</span>
			<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Searching for dvdt max - ValueError&#39;</span>
			<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># minima in dv/dt after spike</span>
		<span class="c1">#postRange = dvdt[self.spikeTimes[i]:postMinPnt]</span>
		<span class="c1">#postSpike_ms = 20 # 10</span>
		<span class="c1">#postSpike_pnts = self.ms2Pnt_(postSpike_ms)</span>
		<span class="n">dvdtPostWindow_ms</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;dvdtPostWindow_ms&#39;</span><span class="p">]</span>
		<span class="n">dvdtPostWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dvdtPostWindow_ms</span><span class="p">)</span>
		<span class="n">postRange</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">peakPnt</span><span class="p">:</span><span class="n">peakPnt</span><span class="o">+</span><span class="n">dvdtPostWindow_pnts</span><span class="p">]</span> <span class="c1"># fixed window after spike</span>

		<span class="n">postSpike_dvdt_min_pnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">postRange</span><span class="p">)</span>
		<span class="n">postSpike_dvdt_min_pnt</span> <span class="o">+=</span> <span class="n">peakPnt</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">postSpike_dvdt_min_pnt</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">postSpike_dvdt_min_pnt</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">postSpike_dvdt_min_pnt</span><span class="p">]</span>

		<span class="c1">#</span>
		<span class="c1"># diastolic duration was defined as the interval between MDP and TOP</span>
		<span class="c1"># one off error when preMinPnt is not defined</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;diastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">spikeTime</span> <span class="o">-</span> <span class="n">preMinPnt</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># calculate instantaneous spike frequency and ISI</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">isiPnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span>
			<span class="n">isi_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span>
			<span class="n">isi_hz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">isi_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">isiPnts</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;spikeFreq_hz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

			<span class="c1"># Cycle length was defined as the interval between MDPs in successive APs</span>
			<span class="n">prevPreMinPnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span> <span class="c1"># can be nan</span>
			<span class="n">thisPreMinPnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">prevPreMinPnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thisPreMinPnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">cycleLength_pnts</span> <span class="o">=</span> <span class="n">thisPreMinPnt</span> <span class="o">-</span> <span class="n">prevPreMinPnt</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycleLength_pnts</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">cycleLength_pnts</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># error</span>
				<span class="n">prevPreMinSec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Sec_</span><span class="p">(</span><span class="n">prevPreMinPnt</span><span class="p">)</span>
				<span class="n">thisPreMinSec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Sec_</span><span class="p">(</span><span class="n">thisPreMinPnt</span><span class="p">)</span>
				<span class="c1">#errorStr = f&#39;Previous spike preMinPnt is {prevPreMinPnt} and this preMinPnt: {thisPreMinPnt}&#39;</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Cycle Length&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Previous spike preMinPnt (s) is </span><span class="si">{</span><span class="n">prevPreMinSec</span><span class="si">}</span><span class="s1"> and this preMinPnt: </span><span class="si">{</span><span class="n">thisPreMinSec</span><span class="si">}</span><span class="s1">&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># TODO: Move half-width to a function !!!</span>
		<span class="c1">#</span>
		<span class="n">hwWindowPnts</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfWidthWindow_ms&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span>
		<span class="n">hwWindowPnts</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">hwWindowPnts</span><span class="p">)</span>
		<span class="n">halfHeightList</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_getHalfWidth</span><span class="p">(</span><span class="n">filteredVm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">iIdx</span><span class="p">,</span> <span class="n">spikeTime</span><span class="p">,</span> <span class="n">peakPnt</span><span class="p">,</span> <span class="n">hwWindowPnts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">,</span> <span class="n">halfHeightList</span><span class="p">)</span>
		<span class="c1">#for i in range(1):</span>
		<span class="c1">#	self.spikeDict[iIdx][&#39;widths_&#39;+str(halfHeight)] = widthMs</span>
		<span class="c1">#	self.spikeDict[iIdx][&#39;widths&#39;][j] = widthDict</span>

	<span class="c1">#</span>
	<span class="c1"># look between threshold crossing to get minima</span>
	<span class="c1"># we will ignore the first and last spike</span>

	<span class="c1">#</span>
	<span class="c1"># spike clips</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x2</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="c1">#</span>
	<span class="c1"># generate a df holding stats (used by scatterplotwidget)</span>
	<span class="n">startSeconds</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;startSeconds&#39;</span><span class="p">]</span>
	<span class="n">stopSeconds</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;stopSeconds&#39;</span><span class="p">]</span>
	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSpikes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">exportObject</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bExport</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dfReportForScatter</span> <span class="o">=</span> <span class="n">exportObject</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">startSeconds</span><span class="p">,</span> <span class="n">stopSeconds</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dfReportForScatter</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">dfError</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorReport</span><span class="p">()</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_detectionDirty</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># e.g. bAnalysis needs to be saved</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.pnt2Ms_" class="doc doc-heading">
<code class="highlight language-python"><span class="n">pnt2Ms_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pnt</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.pnt2Ms_" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Convert a point to milliseconds (ms) using <code>self.dataPointsPerMs</code></p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>pnt</code></td>
        <td><code>int</code></td>
        <td><p>The point</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>float</code></td>
      <td><p>The point in milliseconds (ms)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">pnt2Ms_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pnt</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Convert a point to milliseconds (ms) using `self.dataPointsPerMs`</span>

<span class="sd">	Args:</span>
<span class="sd">		pnt (int): The point</span>

<span class="sd">	Returns:</span>
<span class="sd">		float: The point in milliseconds (ms)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="n">pnt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.pnt2Sec_" class="doc doc-heading">
<code class="highlight language-python"><span class="n">pnt2Sec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pnt</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.pnt2Sec_" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Convert a point to Seconds using <code>self.dataPointsPerMs</code></p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>pnt</code></td>
        <td><code>int</code></td>
        <td><p>The point</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>float</code></td>
      <td><p>The point in seconds</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">pnt2Sec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pnt</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Convert a point to Seconds using `self.dataPointsPerMs`</span>

<span class="sd">	Args:</span>
<span class="sd">		pnt (int): The point</span>

<span class="sd">	Returns:</span>
<span class="sd">		float: The point in seconds</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">pnt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="c1">#return math.isnan(pnt)</span>
		<span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">pnt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span> <span class="o">/</span> <span class="mi">1000</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.printSpike" class="doc doc-heading">
<code class="highlight language-python"><span class="n">printSpike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.printSpike" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Print values in one spike analysis using self.spikeDict (sanpy.bAnalysisResults).</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">printSpike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Print values in one spike analysis using self.spikeDict (sanpy.bAnalysisResults).</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">spike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">spike</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span>
			<span class="n">widths</span> <span class="o">=</span> <span class="n">v</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  spike:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span><span class="si">}</span><span class="s1"> widths...&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">wIdx</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
				<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    spike:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> width:</span><span class="si">{</span><span class="n">wIdx</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;errors&#39;</span><span class="p">:</span>
			<span class="n">errors</span> <span class="o">=</span> <span class="n">v</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  spike:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span><span class="si">}</span><span class="s1"> errors...&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">eIdx</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">errors</span><span class="p">):</span>
				<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    spike:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> error #:</span><span class="si">{</span><span class="n">eIdx</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">error</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.recordingDur" class="doc doc-heading">
<code class="highlight language-python"><span class="n">recordingDur</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.recordingDur" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get recording duration in seconds.</p>
<p>If there are multiple sweeps, assuming all are the same duration.</p>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.recordingFrequency" class="doc doc-heading">
<code class="highlight language-python"><span class="n">recordingFrequency</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.recordingFrequency" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get recording frequency in kHz.</p>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.save_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.save_csv" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Save as a CSV text file with name <path>_analysis.csv'</p>
<p>TODO: Fix
TODO: We need to save header with xxx
TODO: Load <path>_analysis.csv</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">save_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Save as a CSV text file with name &lt;path&gt;_analysis.csv&#39;</span>

<span class="sd">	TODO: Fix</span>
<span class="sd">	TODO: We need to save header with xxx</span>
<span class="sd">	TODO: Load &lt;path&gt;_analysis.csv</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">savefile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">savefile</span> <span class="o">+=</span> <span class="s1">&#39;_analysis.csv&#39;</span>
	<span class="n">saveExcel</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="n">alsoSaveTxt</span> <span class="o">=</span> <span class="kc">True</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saving &quot;</span><span class="si">{</span><span class="n">savefile</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

	<span class="n">be</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bExport</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
	<span class="n">be</span><span class="o">.</span><span class="n">saveReport</span><span class="p">(</span><span class="n">savefile</span><span class="p">,</span> <span class="n">saveExcel</span><span class="o">=</span><span class="n">saveExcel</span><span class="p">,</span> <span class="n">alsoSaveTxt</span><span class="o">=</span><span class="n">alsoSaveTxt</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.setSpikeStat" class="doc doc-heading">
<code class="highlight language-python"><span class="n">setSpikeStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikeList</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.setSpikeStat" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Used to set simple things like ('isBad', 'userType1', ...)</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">setSpikeStat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikeList</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Used to set simple things like (&#39;isBad&#39;, &#39;userType1&#39;, ...)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikeList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">spike</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">spikeList</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">spike</span><span class="p">[</span><span class="n">stat</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
				<span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
	<span class="c1">#</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Given </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spikeList</span><span class="p">)</span><span class="si">}</span><span class="s1"> and set </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>








  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.spikeDetect" class="doc doc-heading">
<code class="highlight language-python"><span class="n">spikeDetect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detectionClass</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Spike Detect all sweeps.</p>
<p>When we are instantiated we create a default self.detectionClass</p>
<p>Each spike is a row and has 'sweep'</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">spikeDetect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detectionClass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Spike Detect all sweeps.</span>

<span class="sd">	When we are instantiated we create a default self.detectionClass</span>

<span class="sd">	Each spike is a row and has &#39;sweep&#39;</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">rememberSweep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentSweep</span>  <span class="c1"># This is BAD we are mixing analysis with interface !!!</span>

	<span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">detectionClass</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">detectionClass</span> <span class="o">=</span> <span class="n">detectionClass</span>

	<span class="c1">#</span>
	<span class="c1"># todo: ask user if they want to remove their settings for (isBad, userType)</span>
	<span class="c1">#</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_isAnalyzed</span> <span class="o">=</span> <span class="kc">True</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># we are filling this in, one dict for each spike</span>

	<span class="k">for</span> <span class="n">sweepNumber</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepList</span><span class="p">:</span>
		<span class="c1">#self.setSweep(sweep)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikeDetect2__</span><span class="p">(</span><span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">detectionClass</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">rememberSweep</span><span class="p">)</span>

	<span class="n">stopTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">detectionClass</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span><span class="p">)</span><span class="si">}</span><span class="s1"> spikes in </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">stopTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h2 id="sanpy.bAnalysis_.bAnalysis.spikeDetect2__" class="doc doc-heading">
<code class="highlight language-python"><span class="n">spikeDetect2__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">)</span></code>


<a href="#sanpy.bAnalysis_.bAnalysis.spikeDetect2__" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Working on using bAnalysisResult.py.</p>

        <details class="quote">
          <summary>Source code in <code>sanpy/bAnalysis_.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">spikeDetect2__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Working on using bAnalysisResult.py.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># a list of dict of sanpy.bAnalysisResults.analysisResult (one dict per spike)</span>
	<span class="n">spikeDict</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">analysisResultList</span><span class="p">()</span>
	<span class="c1"># append one spike</span>
	<span class="c1">#arl.appendDefault()</span>

	<span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="k">if</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
		<span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;=== dDict is:&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
			<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1"> &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">sweepNumber</span><span class="p">)</span>
	<span class="c1">#</span>

	<span class="c1"># in case dDict has new filter values</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">rebuildFiltered</span><span class="p">()</span>

	<span class="c1">#</span>
	<span class="c1"># spike detect</span>
	<span class="n">detectionType</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;detectionType&#39;</span><span class="p">]</span>
	<span class="c1">#logger.info(f&#39;detectionType: &quot;{detectionType}&#39;)</span>

	<span class="c1"># detect all spikes either with dvdt or mv</span>
	<span class="k">if</span> <span class="n">detectionType</span> <span class="o">==</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bDetection</span><span class="o">.</span><span class="n">detectionTypes</span><span class="o">.</span><span class="n">mv</span><span class="p">:</span>
		<span class="c1"># detect using mV threshold</span>
		<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikeDetect_vm</span><span class="p">(</span><span class="n">dDict</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">)</span>

		<span class="c1"># backup childish vm threshold</span>
		<span class="k">if</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;doBackupSpikeVm&#39;</span><span class="p">]:</span>
			<span class="n">spikeTimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backupSpikeVm</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">,</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">])</span>
	<span class="k">elif</span> <span class="n">detectionType</span> <span class="o">==</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bDetection</span><span class="o">.</span><span class="n">detectionTypes</span><span class="o">.</span><span class="n">dvdt</span><span class="p">:</span>
		<span class="c1"># detect using dv/dt threshold AND min mV</span>
		<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spikeDetect_dvdt</span><span class="p">(</span><span class="n">dDict</span><span class="p">,</span> <span class="n">sweepNumber</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown detection type &quot;</span><span class="si">{</span><span class="n">detectionType</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
		<span class="k">return</span>

	<span class="c1">#</span>
	<span class="c1"># set up</span>
	<span class="n">sweepX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepX</span>  <span class="c1"># sweepNumber is not optional</span>
	<span class="n">filteredVm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredVm</span>  <span class="c1"># sweepNumber is not optional</span>
	<span class="n">filteredDeriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredDeriv</span>
	<span class="n">sweepC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweepC</span>

	<span class="c1">#</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
	<span class="n">dateStr</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">dateAnalyzed</span> <span class="o">=</span> <span class="n">dateStr</span>

	<span class="c1">#</span>
	<span class="c1"># look in a window after each threshold crossing to get AP peak</span>
	<span class="n">peakWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;peakWindow_ms&#39;</span><span class="p">])</span>

	<span class="c1">#</span>
	<span class="c1"># throw out spikes that have peak BELOW onlyPeaksAbove_mV</span>
	<span class="c1"># throw out spikes that have peak ABOVE onlyPeaksBelow_mV</span>
	<span class="n">onlyPeaksAbove_mV</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;onlyPeaksAbove_mV&#39;</span><span class="p">]</span>
	<span class="n">onlyPeaksBelow_mV</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;onlyPeaksBelow_mV&#39;</span><span class="p">]</span>
	<span class="n">spikeTimes</span><span class="p">,</span><span class="n">spikeErrorList</span><span class="p">,</span> <span class="n">newSpikePeakPnt</span><span class="p">,</span> <span class="n">newSpikePeakVal</span> \
	 				<span class="o">=</span> <span class="n">throwOutAboveBelow_</span><span class="p">(</span><span class="n">filteredVm</span><span class="p">,</span>
							<span class="n">spikeTimes</span><span class="p">,</span> <span class="n">spikeErrorList</span><span class="p">,</span>
							<span class="n">peakWindow_pnts</span><span class="p">,</span>
							<span class="n">onlyPeaksAbove_mV</span><span class="o">=</span><span class="n">onlyPeaksAbove_mV</span><span class="p">,</span>
							<span class="n">onlyPeaksBelow_mV</span><span class="o">=</span><span class="n">onlyPeaksBelow_mV</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="c1"># small window to average Vm to calculate MDP (itself in a window before spike)</span>
	<span class="n">avgWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;avgWindow_ms&#39;</span><span class="p">])</span>
	<span class="n">avgWindow_pnts</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">avgWindow_pnts</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="c1"># for each spike</span>
	<span class="n">numSpikes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spikeTime</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikeTimes</span><span class="p">):</span>
		<span class="c1"># spikeTime units is ALWAYS points</span>

		<span class="c1"># new, add a spike dict for this spike time</span>
		<span class="n">spikeDict</span><span class="o">.</span><span class="n">appendDefault</span><span class="p">()</span>

		<span class="c1"># get the AP peak</span>
		<span class="n">peakPnt</span> <span class="o">=</span> <span class="n">newSpikePeakPnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">peakVal</span> <span class="o">=</span> <span class="n">newSpikePeakVal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">peakSec</span> <span class="o">=</span> <span class="p">(</span><span class="n">newSpikePeakPnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>

		<span class="c1"># create one spike dictionary</span>
		<span class="c1">#spikeDict = OrderedDict() # use OrderedDict so Pandas output is in the correct order</span>

		<span class="c1">#spikeDict[i][&#39;isBad&#39;] = False</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;analysisVersion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">analysisVersion</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;interfaceVersion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">interfaceVersion</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFileName</span><span class="p">()</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;detectionType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectionType</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;cellType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;cellType&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;sex&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sweep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sweepNumber</span>
		<span class="c1"># keep track of per sweep spike and total spike</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sweepSpikeNumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;spikeNumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># self.numSpikes</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;include&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="c1"># todo: make this a byte encoding so we can have multiple user tyes per spike</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;userType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># One userType (int) that can have values</span>

		<span class="c1"># using bAnalysisResults will already be []</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c1"># append existing spikeErrorList from spikeDetect_dvdt() or spikeDetect_mv()</span>
		<span class="n">tmpError</span> <span class="o">=</span> <span class="n">spikeErrorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">tmpError</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmpError</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpError</span><span class="p">)</span> <span class="c1"># tmpError is from:</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> error from main detection:</span><span class="si">{</span><span class="n">tmpError</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
		<span class="c1">#</span>
		<span class="c1"># detection params</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;dvdtThreshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;dvdtThreshold&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;mvThreshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;mvThreshold&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;medianFilter&#39;</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikeTime</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;thresholdSec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">spikeTime</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;thresholdVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span> <span class="c1"># in vm</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;thresholdVal_dvdt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span> <span class="c1"># in dvdt, spikeTime is points</span>

		<span class="c1"># DAC command at the precise spike point</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;dacCommand&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sweepC</span><span class="p">[</span><span class="n">spikeTime</span><span class="p">]</span>  <span class="c1"># spikeTime is in points</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;peakPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakPnt</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;peakSec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakSec</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;peakVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakVal</span>

		<span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;peakHeight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;peakVal&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;thresholdVal&#39;</span><span class="p">]</span>

		<span class="c1">#</span>
		<span class="c1"># only append to spikeDict after we are done (accounting for spikes within a sweep)</span>
		<span class="c1"># was this</span>
		<span class="c1">#self.spikeDict.append(spikeDict)</span>
		<span class="c1">#iIdx = len(self.spikeDict) - 1</span>
		<span class="c1">#</span>
		<span class="c1">#</span>

		<span class="n">iIdx</span> <span class="o">=</span> <span class="n">i</span>

		<span class="c1">#</span>
		<span class="c1"># was this, assigning default</span>

		<span class="c1"># todo: get rid of this</span>
		<span class="n">defaultVal</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>

		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		# get pre/post spike minima</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preMinPnt&#39;] = None</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preMinVal&#39;] = defaultVal</span>

<span class="sd">		# early diastolic duration</span>
<span class="sd">		# 0.1 to 0.5 of time between pre spike min and spike time</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preLinearFitPnt0&#39;] = None</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preLinearFitPnt1&#39;] = None</span>
<span class="sd">		self.spikeDict[iIdx][&#39;earlyDiastolicDuration_ms&#39;] = defaultVal # seconds between preLinearFitPnt0 and preLinearFitPnt1</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preLinearFitVal0&#39;] = defaultVal</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preLinearFitVal1&#39;] = defaultVal</span>
<span class="sd">		# m,b = np.polyfit(x, y, 1)</span>
<span class="sd">		self.spikeDict[iIdx][&#39;earlyDiastolicDurationRate&#39;] = defaultVal # fit of y=preLinearFitVal 0/1 versus x=preLinearFitPnt 0/1</span>
<span class="sd">		self.spikeDict[iIdx][&#39;lateDiastolicDuration&#39;] = defaultVal #</span>

<span class="sd">		self.spikeDict[iIdx][&#39;preSpike_dvdt_max_pnt&#39;] = None</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preSpike_dvdt_max_val&#39;] = defaultVal # in units mV</span>
<span class="sd">		self.spikeDict[iIdx][&#39;preSpike_dvdt_max_val2&#39;] = defaultVal # in units dv/dt</span>
<span class="sd">		self.spikeDict[iIdx][&#39;postSpike_dvdt_min_pnt&#39;] = None</span>
<span class="sd">		self.spikeDict[iIdx][&#39;postSpike_dvdt_min_val&#39;] = defaultVal # in units mV</span>
<span class="sd">		self.spikeDict[iIdx][&#39;postSpike_dvdt_min_val2&#39;] = defaultVal # in units dv/dt</span>

<span class="sd">		self.spikeDict[iIdx][&#39;isi_pnts&#39;] = defaultVal # time between successive AP thresholds (thresholdSec)</span>
<span class="sd">		self.spikeDict[iIdx][&#39;isi_ms&#39;] = defaultVal # time between successive AP thresholds (thresholdSec)</span>
<span class="sd">		self.spikeDict[iIdx][&#39;spikeFreq_hz&#39;] = defaultVal # time between successive AP thresholds (thresholdSec)</span>
<span class="sd">		self.spikeDict[iIdx][&#39;cycleLength_pnts&#39;] = defaultVal # time between successive MDPs</span>
<span class="sd">		self.spikeDict[iIdx][&#39;cycleLength_ms&#39;] = defaultVal # time between successive MDPs</span>

<span class="sd">		# Action potential duration (APD) was defined as the interval between the TOP and the subsequent MDP</span>
<span class="sd">		#self.spikeDict[iIdx][&#39;apDuration_ms&#39;] = defaultVal</span>
<span class="sd">		self.spikeDict[iIdx][&#39;diastolicDuration_ms&#39;] = defaultVal</span>

<span class="sd">		# any number of spike widths</span>
<span class="sd">		#print(&#39;spikeDetect__() appending widths list to spike iIdx:&#39;, iIdx)</span>
<span class="sd">		# was this</span>
<span class="sd">		#self.spikeDict[iIdx][&#39;widths&#39;] = []</span>
<span class="sd">		# debug 20210929, self._getHalfWidth() will assign spikeDict[iIdx][&#39;widths&#39;] = []</span>
<span class="sd">		for halfHeight in dDict[&#39;halfHeights&#39;]:</span>
<span class="sd">			widthDict = {</span>
<span class="sd">				&#39;halfHeight&#39;: halfHeight,</span>
<span class="sd">				&#39;risingPnt&#39;: None,</span>
<span class="sd">				&#39;risingVal&#39;: defaultVal,</span>
<span class="sd">				&#39;fallingPnt&#39;: None,</span>
<span class="sd">				&#39;fallingVal&#39;: defaultVal,</span>
<span class="sd">				&#39;widthPnts&#39;: None,</span>
<span class="sd">				&#39;widthMs&#39;: defaultVal</span>
<span class="sd">			}</span>
<span class="sd">			# was this</span>
<span class="sd">			#spikeDict[iIdx][&#39;widths_&#39; + str(halfHeight)] = defaultVal</span>
<span class="sd">			spikeDict[iIdx][&#39;widths&#39;].append(widthDict)</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="c1">#</span>
		<span class="n">mdp_ms</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;mdp_ms&#39;</span><span class="p">]</span>
		<span class="n">mdp_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">mdp_ms</span><span class="p">)</span>  <span class="c1"># mdp_ms * self.dataPointsPerMs</span>
		<span class="n">mdp_pnts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mdp_pnts</span><span class="p">)</span>

		<span class="c1"># pre spike min</span>
		<span class="c1"># other algorithms look between spike[i-1] and spike[i]</span>
		<span class="c1"># here we are looking in a predefined window</span>
		<span class="n">startPnt</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">mdp_pnts</span>
		<span class="k">if</span> <span class="n">startPnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;TODO: add an official warning, we went past 0 for pre spike mdp ms window&#39;</span><span class="p">)</span>
			<span class="n">startPnt</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">startPnt</span><span class="p">:</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1"># EXCEPTION</span>
		<span class="n">preMinPnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span>
		<span class="n">preMinPnt</span> <span class="o">+=</span> <span class="n">startPnt</span>
		<span class="c1"># the pre min is actually an average around the real minima</span>
		<span class="n">avgRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preMinPnt</span><span class="o">-</span><span class="n">avgWindow_pnts</span><span class="p">:</span><span class="n">preMinPnt</span><span class="o">+</span><span class="n">avgWindow_pnts</span><span class="p">]</span>
		<span class="n">preMinVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">avgRange</span><span class="p">)</span>

		<span class="c1"># search backward from spike to find when vm reaches preMinVal (avg)</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preMinPnt</span><span class="p">:</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
		<span class="n">preRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span> <span class="c1"># we want to search backwards from peak</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">preMinPnt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">preRange</span><span class="o">&lt;</span><span class="n">preMinVal</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">preMinPnt</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">preMinPnt2</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preMinPnt</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinVal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preMinVal</span>

		<span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Pre spike min (mdp)&#39;</span>
			<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Did not find preMinVal: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">preMinVal</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1">#+ &#39; postRange min:&#39; + str(np.min(postRange)) + &#39; max &#39; + str(np.max(postRange))</span>
			<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
		<span class="c1">#</span>
		<span class="c1"># The nonlinear late diastolic depolarization phase was</span>
		<span class="c1"># estimated as the duration between 1% and 10% dV/dt</span>
		<span class="c1"># linear fit on 10% - 50% of the time from preMinPnt to self.spikeTimes[i]</span>
		<span class="n">startLinearFit</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># percent of time between pre spike min and AP peak</span>
		<span class="n">stopLinearFit</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1">#</span>
		<span class="n">timeInterval_pnts</span> <span class="o">=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">preMinPnt</span>
		<span class="c1"># taking round() so we always get an integer # points</span>
		<span class="n">preLinearFitPnt0</span> <span class="o">=</span> <span class="n">preMinPnt</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="n">timeInterval_pnts</span> <span class="o">*</span> <span class="n">startLinearFit</span><span class="p">)</span>
		<span class="n">preLinearFitPnt1</span> <span class="o">=</span> <span class="n">preMinPnt</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="n">timeInterval_pnts</span> <span class="o">*</span> <span class="n">stopLinearFit</span><span class="p">)</span>
		<span class="n">preLinearFitVal0</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">]</span>
		<span class="n">preLinearFitVal1</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>

		<span class="c1"># linear fit before spike</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitPnt0</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitPnt1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitPnt1</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">preLinearFitPnt1</span> <span class="o">-</span> <span class="n">preLinearFitPnt0</span><span class="p">)</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitVal0</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preLinearFitVal1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preLinearFitVal1</span>

		<span class="c1"># a linear fit where &#39;m,b = np.polyfit(x, y, 1)&#39;</span>
		<span class="c1"># m*x+b&quot;</span>
		<span class="n">xFit</span> <span class="o">=</span> <span class="n">sweepX</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">:</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>  <span class="c1"># abb added +1</span>
		<span class="n">yFit</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preLinearFitPnt0</span><span class="p">:</span><span class="n">preLinearFitPnt1</span><span class="p">]</span>

		<span class="c1"># sometimes xFit/yFit have 0 length --&gt;&gt; TypeError</span>
		<span class="c1">#print(f&#39; {iIdx} preLinearFitPnt0:{preLinearFitPnt0}, preLinearFitPnt1:{preLinearFitPnt1}&#39;)</span>
		<span class="c1">#print(f&#39;    xFit:{len(xFit)} yFit:{len(yFit)}&#39;)</span>

		<span class="c1"># TODO: I need to trigger following errors to confirm code works !!!!</span>
		<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">mLinear</span><span class="p">,</span> <span class="n">bLinear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xFit</span><span class="p">,</span> <span class="n">yFit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># m is slope, b is intercept</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mLinear</span>
				<span class="c1"># todo: make an error if edd rate is too low</span>
				<span class="n">lowestEddRate</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;lowEddRate_warning&#39;</span><span class="p">]</span>  <span class="c1">#8</span>
				<span class="k">if</span> <span class="n">mLinear</span> <span class="o">&lt;=</span> <span class="n">lowestEddRate</span><span class="p">:</span>
					<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
					<span class="n">errorStr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Early diastolic duration rate fit - Too low </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">mLinear</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">&lt;=</span><span class="si">{</span><span class="n">lowestEddRate</span><span class="si">}</span><span class="s1">&#39;</span>
					<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
					<span class="c1">#print(&#39;fit edd start num error:&#39;, &#39;iIdx:&#39;, iIdx, &#39;num error:&#39;, len(spikeDict[iIdx][&#39;errors&#39;]))</span>
					<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
					<span class="c1">#print(&#39;  after num error:&#39;, len(spikeDict[iIdx][&#39;errors&#39;]))</span>
					<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

			<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="c1">#catching exception:  expected non-empty vector for x</span>
				<span class="c1"># xFit/yFit turn up empty when mdp and TOP points are within 1 point</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="c1">#errorStr = &#39;Early diastolic duration rate fit - TypeError&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - preMinPnt == spikePnt&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
			<span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
				<span class="c1">#logger.error(&#39;== FIX preLinearFitPnt0/preLinearFitPnt1 RankWarning&#39;)</span>
				<span class="c1">#logger.error(f&#39;  error is: {e}&#39;)</span>
				<span class="c1">#print(&#39;RankWarning&#39;)</span>
				<span class="c1"># also throws: RankWarning: Polyfit may be poorly conditioned</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - RankWarning&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; !!!!!!!!!!!!!!!!!!!!!!!!!!! UNKNOWN EXCEPTION DURING EDD LINEAR FIT for spike </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;earlyDiastolicDurationRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVal</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Fit EDD&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Early diastolic duration rate fit - Unknown Exception&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

		<span class="c1"># not implemented</span>
		<span class="c1">#self.spikeDict[i][&#39;lateDiastolicDuration&#39;] = ???</span>

		<span class="c1">#</span>
		<span class="c1"># maxima in dv/dt before spike (between TOP and peak)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">preRange</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">peakPnt</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">preSpike_dvdt_max_pnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preRange</span><span class="p">)</span>
			<span class="n">preSpike_dvdt_max_pnt</span> <span class="o">+=</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">preSpike_dvdt_max_pnt</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">preSpike_dvdt_max_pnt</span><span class="p">]</span> <span class="c1"># in units mV</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preSpike_dvdt_max_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">preSpike_dvdt_max_pnt</span><span class="p">]</span> <span class="c1"># in units mV</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
			<span class="c1"># sometimes preRange is empty, don&#39;t try and put min/max in error</span>
			<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Pre Spike dvdt&#39;</span>
			<span class="n">errorStr</span> <span class="o">=</span> <span class="s1">&#39;Searching for dvdt max - ValueError&#39;</span>
			<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># minima in dv/dt after spike</span>
		<span class="c1">#postRange = dvdt[self.spikeTimes[i]:postMinPnt]</span>
		<span class="c1">#postSpike_ms = 20 # 10</span>
		<span class="c1">#postSpike_pnts = self.ms2Pnt_(postSpike_ms)</span>
		<span class="n">dvdtPostWindow_ms</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;dvdtPostWindow_ms&#39;</span><span class="p">]</span>
		<span class="n">dvdtPostWindow_pnts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ms2Pnt_</span><span class="p">(</span><span class="n">dvdtPostWindow_ms</span><span class="p">)</span>
		<span class="n">postRange</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">peakPnt</span><span class="p">:</span><span class="n">peakPnt</span><span class="o">+</span><span class="n">dvdtPostWindow_pnts</span><span class="p">]</span> <span class="c1"># fixed window after spike</span>

		<span class="n">postSpike_dvdt_min_pnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">postRange</span><span class="p">)</span>
		<span class="n">postSpike_dvdt_min_pnt</span> <span class="o">+=</span> <span class="n">peakPnt</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_pnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">postSpike_dvdt_min_pnt</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredVm</span><span class="p">[</span><span class="n">postSpike_dvdt_min_pnt</span><span class="p">]</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;postSpike_dvdt_min_val2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filteredDeriv</span><span class="p">[</span><span class="n">postSpike_dvdt_min_pnt</span><span class="p">]</span>

		<span class="c1">#</span>
		<span class="c1"># diastolic duration was defined as the interval between MDP and TOP</span>
		<span class="c1"># one off error when preMinPnt is not defined</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;diastolicDuration_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">spikeTime</span> <span class="o">-</span> <span class="n">preMinPnt</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># calculate instantaneous spike frequency and ISI, for first spike this is not defined</span>
		<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">isiPnts</span> <span class="o">=</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;thresholdPnt&#39;</span><span class="p">]</span>
			<span class="n">isi_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span>
			<span class="n">isi_hz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">isi_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">isiPnts</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;isi_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span>
			<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;spikeFreq_hz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">isiPnts</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

			<span class="c1"># Cycle length was defined as the interval between MDPs in successive APs</span>
			<span class="n">prevPreMinPnt</span> <span class="o">=</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span> <span class="c1"># can be nan</span>
			<span class="n">thisPreMinPnt</span> <span class="o">=</span> <span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;preMinPnt&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">prevPreMinPnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thisPreMinPnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">cycleLength_pnts</span> <span class="o">=</span> <span class="n">thisPreMinPnt</span> <span class="o">-</span> <span class="n">prevPreMinPnt</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_pnts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycleLength_pnts</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;cycleLength_ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Ms_</span><span class="p">(</span><span class="n">cycleLength_pnts</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># error</span>
				<span class="n">prevPreMinSec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Sec_</span><span class="p">(</span><span class="n">prevPreMinPnt</span><span class="p">)</span>
				<span class="n">thisPreMinSec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnt2Sec_</span><span class="p">(</span><span class="n">thisPreMinPnt</span><span class="p">)</span>
				<span class="c1">#errorStr = f&#39;Previous spike preMinPnt is {prevPreMinPnt} and this preMinPnt: {thisPreMinPnt}&#39;</span>
				<span class="n">errorType</span> <span class="o">=</span> <span class="s1">&#39;Cycle Length&#39;</span>
				<span class="n">errorStr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Previous spike preMinPnt (s) is </span><span class="si">{</span><span class="n">prevPreMinSec</span><span class="si">}</span><span class="s1"> and this preMinPnt: </span><span class="si">{</span><span class="n">thisPreMinSec</span><span class="si">}</span><span class="s1">&#39;</span>
				<span class="n">eDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getErrorDict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spikeTimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">errorStr</span><span class="p">)</span> <span class="c1"># spikeTime is in pnts</span>
				<span class="n">spikeDict</span><span class="p">[</span><span class="n">iIdx</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eDict</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;spike:</span><span class="si">{</span><span class="n">iIdx</span><span class="si">}</span><span class="s1"> error:</span><span class="si">{</span><span class="n">eDict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

		<span class="c1">#</span>
		<span class="c1"># TODO: Move half-width to a function !!!</span>
		<span class="c1">#</span>
		<span class="n">hwWindowPnts</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfWidthWindow_ms&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span>
		<span class="n">hwWindowPnts</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">hwWindowPnts</span><span class="p">)</span>
		<span class="n">halfHeightList</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;halfHeights&#39;</span><span class="p">]</span>
		<span class="c1"># was this</span>
		<span class="c1">#self._getHalfWidth(filteredVm, i, iIdx, spikeTime, peakPnt, hwWindowPnts, self.dataPointsPerMs, halfHeightList)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_getHalfWidth</span><span class="p">(</span><span class="n">filteredVm</span><span class="p">,</span> <span class="n">iIdx</span><span class="p">,</span> <span class="n">spikeDict</span><span class="p">,</span> <span class="n">spikeTime</span><span class="p">,</span> <span class="n">peakPnt</span><span class="p">,</span> <span class="n">hwWindowPnts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataPointsPerMs</span><span class="p">,</span> <span class="n">halfHeightList</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

	<span class="c1">#</span>
	<span class="c1"># look between threshold crossing to get minima</span>
	<span class="c1"># we will ignore the first and last spike</span>

	<span class="c1">#</span>
	<span class="c1"># spike clips</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeClips_x2</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="c1"># SUPER important, previously our self.spikeDict was simple list of dict</span>
	<span class="c1"># now it is a list of class xxx</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">spikeDict</span> <span class="o">=</span> <span class="n">spikeDict</span>

	<span class="c1">#</span>
	<span class="c1"># generate a df holding stats (used by scatterplotwidget)</span>
	<span class="n">startSeconds</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;startSeconds&#39;</span><span class="p">]</span>
	<span class="n">stopSeconds</span> <span class="o">=</span> <span class="n">dDict</span><span class="p">[</span><span class="s1">&#39;stopSeconds&#39;</span><span class="p">]</span>
	<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSpikes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">exportObject</span> <span class="o">=</span> <span class="n">sanpy</span><span class="o">.</span><span class="n">bExport</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dfReportForScatter</span> <span class="o">=</span> <span class="n">exportObject</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">startSeconds</span><span class="p">,</span> <span class="n">stopSeconds</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dfReportForScatter</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">dfError</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorReport</span><span class="p">()</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">_detectionDirty</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># e.g. bAnalysis needs to be saved</span>

	<span class="c1"># run all user analysis ... what if this fails ???</span>
	<span class="n">sanpy</span><span class="o">.</span><span class="n">userAnalysis</span><span class="o">.</span><span class="n">runAllUserAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.sweepC" class="doc doc-heading">
<code class="highlight language-python"><span class="n">sweepC</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.sweepC" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the command waveform DAC (numpy.ndarray). Units will depend on mode</p>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.sweepList" class="doc doc-heading">
<code class="highlight language-python"><span class="n">sweepList</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.sweepList" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the list of sweeps.</p>
    </div>

  </div>








  <div class="doc doc-object doc-attribute">



<h2 id="sanpy.bAnalysis_.bAnalysis.sweepY" class="doc doc-heading">
<code class="highlight language-python"><span class="n">sweepY</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#sanpy.bAnalysis_.bAnalysis.sweepY" class="headerlink" title="Permanent link">造</a></h2>

    <div class="doc doc-contents ">

      <p>Get the amplitude (mV or pA) from recording (numpy.ndarray). Units wil depend on mode</p>
    </div>

  </div>





  </div>

    </div>

  </div>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        my footer
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.fcfe8b6d.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.b1047164.min.js"></script>
      
    
  </body>
</html>